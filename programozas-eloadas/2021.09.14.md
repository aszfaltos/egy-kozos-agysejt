---
author: N√°ndi
date: 2021-09-14
---
# El≈ëad√°s 03
Felsorol√°s t√≠pus:
- Nem lehet m√°s csak a felsoroltak k√∂z√ºl 

> A programoz√≥k eg√©szs√©gesen lust√°k. 

- Van olyan nyelv, ami megengedi, hogy nem sz√°mok legyenek az indexek.

-Mem√≥ria c√≠mz√©s hiba

> Indexek sz√°ma legt√∂bb nyelvben 256
> N*N*N M√°trixok

<details>
<summary>2. el≈ëad√°s PPT</summary>
<iframe src="https://drive.google.com/file/d/1hsvaMBfBXFQd1vKXzW4mizNypbYs4cvC/preview" width="640" height="480" allow="autoplay"
	style="
	transform: translateX(-50%);
    position:relative;
    left:50%;
    width: 60vw;
    height: 70vh;">
</iframe>
</details>

<details>
<summary>3. el≈ëad√°s PPT</summary>
<iframe src="https://drive.google.com/file/d/1Kirni7JjYo-Ln-IrGwJIya6lS9tgrR_I/preview" width="640" height="480" allow="autoplay"
	style="
	transform: translateX(-50%);
    position:relative;
    left:50%;
    width: 60vw;
    height: 70vh;">
</iframe>
</details>

## Programoz√°si t√©tel
- 12 feladat√≠pus, mindegyik feladat besorolhat√≥ valamelyikbe
- Hasonl√≥ak egym√°shoz; megold√°s szerint nincs 12 -> 7 db **megold√°s s√©ma **-> 1 megold√°ss√©ma mind felett  
- Be lehet bizony√≠tani matematikai m√≥dszerekkel. De most m√©g csak j√≥zan √©sszel bel√°tjuk
- **Nem biztos√≠tja egyb≈ël a hat√©konys√°got**
> Programtranzform√°ci√≥k

#### Programoz√°si t√©telek c√©lja
Bizony√≠that√≥an helyes sablon, amire lehet √©p√≠teni. Ezzel gyorsabb a fejleszt√©s √©s biztons√°gosabb. 
> Csak az **elvi** helyess√©get biztos√≠tja.
>**A bemenet legal√°bb egy sorozat**

#### Programoz√°si t√©tel felhaszn√°l√°sa
1. Konkr√©t feladat specifik√°l√°sa
2. A specifik√°ci√≥ban a programoz√°si t√©tel megsejt√©se
3. A konkr√©t feladat √©s az absztrakt feladat param√©terei egym√°shoz rendel√©se
4. A konkr√©t algoritmus meg√≠r√°sa
5. Hat√©kony√≠t√°s

### Sorozatsz√°m√≠t√°s
- Mi a k√∂z√∂s?
N darab "valamib≈ël" kell kisz√°molni egy "valamit"

>Term√©szetes sz√°mok: programoz√°sban benne van a 0; praktikus; el≈ëjel n√©lk√ºli eg√©szben is benne van

- Neh√©zs√©g:

> Nem tudunk N tagot egyszerre √∂sszeadni, kezelni stb..

**N tag√∫** m≈±veletet vissza kell vezetni **k√©ttag√∫** m≈±veletre
Kell kezd≈ë √©rt√©k, ha nincs semmi $F_0$

> üìî Szumm√°t legt√∂bb programoz√°si nyelvben megtal√°ljuk

- Algoritmus:
  - Seg√≠t: "Hogyan lehet az eddigi eredm√©nyhez egy √∫jat hozz√° venni?" 
 
 [[sorozatszamitas.png]]

### Megsz√°mol√°s
- Mi a k√∂z√∂s?
N darab "valmire" kell megadni, hogy h√°ny adott tulajdons√°g√∫ van k√∂z√∂tt√ºk. 
> A **T** tulajdons√°g egy logikai f√ºggv√©nyk√©nt adhat√≥ meg.
$$T:\mathbb{H}\rightarrow\mathbb{L}$$

- Eredm√©ny egy *darabsz√°m* $\in\mathbb{N}$

> üìî Megvan a legt√∂bb nyelvben be√©p√≠tve. "Darabha wannabe"
- Algoritmus:
	- Egy el√°gaz√°s T(X\[i\]) felt√©tel√©ben -> darabhoz hozz√°adunk

[[megaszamolas.png]]

### Maximum-kiv√°laszt√°s
- Mi a k√∂z√∂s?
N darab "valami" k√∂z√ºl meg kell adni a *legnagyobbat* (/*legkisebbet*)

>  Kell rendez√©si rel√°ci√≥ az elemek k√∂z√∂tt.

> ‚ö†Ô∏è El≈ëfelt√©tel: Legal√°bb 1 darab "valami" van. 

Eredm√©ny lehet:
- Milyen sorsz√°m√∫ a maxim√°lis?
- Mi a maxim√°lis √©rt√©k?

- Algoritmus:
	- Ha egy valami van ≈ë a maxim√°lis;
	- Ha t√∂bb maxim√°lis van, akkor melyik kell? Az els≈ë, vagy az utols√≥ stb. 	
	>üìì Ha csak sorsz√°m kell
	> - Max = sorsz√°m; 
	> - X\[i] > X\[Max]

[[maximumkivalasztas.png]]

### Keres√©s
- Mi a k√∂z√∂s?
N darab "valami" k√∂z√ºl kell megadni egy adott tulajdons√°g√∫t, ha **nem tudjuk, hogy van-e ilyen elem **
> Ha t√∂bb van nem √©rdekel. El√©g egy. 

Eredm√©ny lehet:
- **Van**
	- Sorsz√°ma/√ârt√©ke
	> üóíÔ∏èSorsz√°mb√≥l t√∂mb√∂k eset√©n k√∂vetkezik az √©rt√©k is. De nem minden sorozat sorsz√°mozhat√≥.
- **Nincs** 

- Algoritmus:
	- Megn√©zz√ºk az els≈ët, ha j√≥ meg√°llunk, ha nem n√©zz√ºk a k√∂vetkez≈ët. 
	- Els≈ët tal√°ljuk meg √©s csak eddig megy√ºnk. 

[[kereses.png]]

## Eld√∂nt√©s 
- Mi a k√∂z√∂s?
D√∂nts√ºk el, hogy N "valami" k√∂z√∂tt van-e adott tulajdons√°ggal rendelkez≈ë elem.
>ü§î Lehetne megsz√°mol√°st alkalmazni
> Db == 0 nincs am√∫gy van
> Csak **nem hat√©kony**

> <- Keres√©sb≈ël j√∂n l√©tre
>  Csak nem √©rdekel, hogy ki lett a T tulajdons√°g√∫; Csak a **Van** marad eredm√©nyk√©nt

- Algoritmus:
	- Leegyszer≈±s√≠tett keres√©s
> Nem csak l√©tezik ($\exists$) t√≠pus√∫ eld√∂nt√©s van. Van Minden ($\forall$) t√≠pus√∫. 
> Pl.: Minden jegye √∂t√∂s <-> Nem igaz, hogy van nem √∂t√∂s jegye. 

[[eldontes.png]]

## Kiv√°laszt√°s 
- Mi a k√∂z√∂s?
N "valami" k√∂z√ºl kell megadni egy adott tulajdons√°got, ha **tudjuk, hogy ilyen elem biztosan van.**

> <- Keres√©sb≈ël j√∂n l√©tre, csak kimarad hogy i$\leq$N

> ‚ö†Ô∏è El≈ëfelt√©tel kell, mert tudjuk, hogy van ilyen. 

[[kivalasztas 1.png]]

### Megjegyz√©s
A kiv√°laszt√°snak √©s az eld√∂nt√©snek az egyetlen szerepe a keres√©ssel szemben, a **hat√©konys√°g** √©s a **hib√°k kisz≈±r√©se**

6-t√©telb≈ël n√©gy elem n√©lk√ºl is helyes eredm√©nyt ad.